name: Semantic Versioning

on:
  workflow_dispatch:
    branches:
      - master
    inputs:
      Environment:
        type: choice
        description: 'The environment to deploy to'
        required: true
        options:
        - test
        - prod
      ContinueOnError:
        type: choice
        description: 'Continue on Snyk and SonarQube scan failures?'
        required: true
        options:
        - false
        - true
      ReleaseType:
        type: choice
        description: 'Type of Release'
        required: true
        options:
        - MAJOR
        - MINOR
        - PATCH
        - BETA
      Release:
        description: 'Select the release name'
        required: false
        default: 'latest'



permissions:
  id-token: write
  contents: write    # This is required for actions/checkout@v3


env:
  SERVICE: openai      
  RC: RC1

jobs:
  deploy:
    name: Deploy
    environment: ${{ github.event.inputs.Environment }}
    runs-on: ubuntu-latest   
    defaults:
      run:
        shell: bash -l {0}
        

    steps:

    - uses: actions/checkout@v3
    - name: Build the site in the jekyll/builder container
      run: |
        docker run \
        -v ${{ github.workspace }}:/srv/jekyll -v ${{ github.workspace }}/_site:/srv/jekyll/_site \
        jekyll/builder:latest /bin/bash -c "chmod -R 777 /srv/jekyll && jekyll build --future"

    - name: Determine current version
      id: determine-version
      run: |
        git fetch --tags
        latestTag=$(git describe --tags --abbrev=0 2>/dev/null)
        currentVersion=${latestTag}

        # Check if the current version does not follow the semantic versioning format
        if ! [[ $currentVersion =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "Invalid semantic version format. Starting from v0.1.0"
          currentVersion="v0.1.0"
        fi

        echo "CURRENT_VERSION=$currentVersion" >> $GITHUB_ENV

    - name: Increment version
      id: increment-version
      run: |
        releaseType=${{ github.event.inputs.ReleaseType }}

        IFS='.' read -r -a versionComponents <<< "${CURRENT_VERSION:1}"
        major=${versionComponents[0]}
        minor=${versionComponents[1]}
        patch=${versionComponents[2]}
        betaCount=0

        case $releaseType in
          MAJOR)
            major=$((major+1))
            minor=0
            patch=0
            newVersion="v${major}.${minor}.${patch}"
            ;;
          MINOR)
            minor=$((minor+1))
            patch=0
            newVersion="v${major}.${minor}.${patch}"
            ;;
          BETA)
            if [[ $currentVersion =~ -beta\.([0-9]+)$ ]]; then
              betaCount=$((BASH_REMATCH[1]+1))
            fi
            newVersion="v${major}.${minor}.${patch}-beta.${betaCount}"
            ;;
          PATCH)
            patch=$((patch+1))
            newVersion="v${major}.${minor}.${patch}"
            ;;
        esac
        
        echo "NEW_VERSION=$newVersion" >> $GITHUB_ENV

    - name: Check if tag already exists
      id: check-tag
      run: |
        if git rev-parse -q --verify "refs/tags/${NEW_VERSION}" >/dev/null; then
          echo "Tag ${NEW_VERSION} already exists."
          echo "EXIT_CODE=1" >> $GITHUB_ENV
        else
          echo "Tag ${NEW_VERSION} does not exist."
          echo "EXIT_CODE=0" >> $GITHUB_ENV
        fi

    - name: Tag and push new version
      run: |
        git tag ${NEW_VERSION}
        git push origin ${NEW_VERSION}

    - name: Create GitHub release
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        releaseNotes="Release ${NEW_VERSION}"

        # Check if the release already exists
        if ! gh release view ${NEW_VERSION} >/dev/null 2>&1; then
          gh release create ${NEW_VERSION} -t ${NEW_VERSION} -n "$releaseNotes"
        fi

